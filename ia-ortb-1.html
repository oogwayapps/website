<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PubScale</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #000000;
      }

      #ad-renderer {
        position: absolute;
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        background: #000000;
      }
    </style>
  </head>
  <body>
    <div id="ad-renderer"></div>
    <script>
      console.log("Version: 1.3.4");
      // Utility function to wait for Vuplex
      async function waitForVuplex() {
        if (!window.vuplex) {
          await new Promise((resolve) => {
            window.addEventListener("vuplexready", resolve, { once: true });
          });
        }
      }

      // Fetch dimensions from Unity
      async function fetchDimensions() {
        await waitForVuplex();
        return new Promise((resolve) => {
          const onMessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === "GetDimensions" && data.dimension) {
              console.log("[DEBUG] Dimensions received:", data.dimension);
              window.vuplex.removeEventListener("message", onMessage);
              resolve({
                width: Number(data.dimension.width),
                height: Number(data.dimension.height),
              });
            }
          };
          window.vuplex.addEventListener("message", onMessage);
          console.log("[DEBUG] Requesting dimensions from Unity...");
          window.vuplex.postMessage({ type: "GetDimensions" });
        });
      }

      // Fetch ad JSON from Unity
      async function fetchAdData() {
        await waitForVuplex();
        return new Promise((resolve) => {
          const onMessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === "GetDemandInfo" && data.demand) {
              console.log("[DEBUG] Ad data received:", data.demand);
              window.vuplex.removeEventListener("message", onMessage);
              resolve(data.demand);
            }
          };
          window.vuplex.addEventListener("message", onMessage);
          console.log("[DEBUG] Requesting ad data from Unity...");
          window.vuplex.postMessage({ type: "GetDemandInfo" });
        });
      }

      // Render ad inside iframe
      async function renderAd() {
        const { width: webViewWidth, height: webViewHeight } =
          await fetchDimensions();
        const adData = await fetchAdData();
        const { w: adWidth, h: adHeight, adm: adHtml } = adData;

        const adRenderer = document.getElementById("ad-renderer");

        // Calculate scale dynamically
        const scaleX = webViewWidth / adWidth;
        const scaleY = webViewHeight / adHeight;
        const scale = Math.min(scaleX, scaleY); // Choose the smaller scale to fit both dimensions

        // Set styles for the container
        Object.assign(adRenderer.style, {
          width: `${webViewWidth}px`,
          height: `${webViewHeight}px`,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        });

        // Create and append the iframe
        const iframe = document.createElement("iframe");
        iframe.width = `${adWidth}px`;
        iframe.height = `${adHeight}px`;
        iframe.scrolling = "no";
        iframe.frameBorder = "0";
        iframe.style.transform = `scale(${scale})`;
        iframe.style.transformOrigin = "center center"; // Center align transform origin
        iframe.style.position = "relative"; // Maintain positioning for centering
        iframe.srcdoc = adHtml;

        adRenderer.innerHTML = ""; // Clear previous content
        adRenderer.appendChild(iframe);

        setupClickRedirection(iframe);
        return { iframe, adWidth, adHeight };
      }
      // Setup click redirection for links in iframe
      function setupClickRedirection(iframe) {
        setTimeout(() => {
          const iframeDoc = iframe.contentDocument;
          const iframeWin = iframe.contentWindow;
          if (!iframeDoc || !iframeWin) {
            console.error("[DEBUG] Iframe document or window is missing.");
            return;
          }

          const redirectLink = (url) => {
            console.log("[DEBUG] Redirecting link to:", url);
            window.vuplex.postMessage({ type: "OpenLink", url });
          };

          // Intercept anchor tag clicks
          iframeDoc.addEventListener("click", (event) => {
            const link = event.target.closest("a[href]");
            if (link) {
              console.log(
                "[DEBUG] Anchor tag clicked. Redirecting:",
                link.href
              );
              event.preventDefault();
              event.stopPropagation();
              redirectLink(link.href);
            }
          });

          // Override `window.open`
          iframeWin.open = (url) => {
            console.log("[DEBUG] Window open intercepted. Redirecting:", url);
            redirectLink(url);
            return null;
          };

          // Override `location.assign` and `location.replace`
          const overrideLocation = (method, url) => {
            console.log(
              `[DEBUG] Location.${method} intercepted. Redirecting:`,
              url
            );
            redirectLink(url);
          };
          iframeWin.location.assign = (url) => overrideLocation("assign", url);
          iframeWin.location.replace = (url) =>
            overrideLocation("replace", url);

          console.log("[DEBUG] Click redirection setup complete.");

          // Setup MutationObserver for nested iframes
          const observeNestedIframes = () => {
            // Handle existing iframes
            const existingIframes = iframeDoc.querySelectorAll("iframe");
            existingIframes.forEach((nestedIframe) => {
              if (!nestedIframe.dataset.redirectionSetup) {
                setupClickRedirection(nestedIframe);
                nestedIframe.dataset.redirectionSetup = "true";
              }
            });

            // Create observer for future iframes
            const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                  if (
                    node.nodeName === "IFRAME" &&
                    !node.dataset.redirectionSetup
                  ) {
                    setupClickRedirection(node);
                    node.dataset.redirectionSetup = "true";
                  }
                  // Check for iframes added within other elements
                  if (node.querySelectorAll) {
                    const nestedIframes = node.querySelectorAll(
                      "iframe:not([data-redirection-setup])"
                    );
                    nestedIframes.forEach((nestedIframe) => {
                      setupClickRedirection(nestedIframe);
                      nestedIframe.dataset.redirectionSetup = "true";
                    });
                  }
                });
              });
            });

            // Start observing with appropriate configuration
            observer.observe(iframeDoc.body, {
              childList: true,
              subtree: true,
            });

            // Store observer reference on iframe document to prevent memory leaks
            iframeDoc._iframeObserver = observer;
          };

          // Ensure body exists before setting up observer
          if (iframeDoc.body) {
            observeNestedIframes();
          } else {
            // Wait for body if it doesn't exist yet
            iframeDoc.addEventListener(
              "DOMContentLoaded",
              observeNestedIframes
            );
          }
        }, 100); // Wait for iframe content to load
      }

      function getCleanDomStructure(document) {
        if (!document) {
          console.error("[DEBUG] Document is missing.");
          return;
        }

        // Remove all script, styles, and meta tags
        const allScripts = document.querySelectorAll("script");
        allScripts.forEach((script) => script.remove());
        const allStyles = document.querySelectorAll("style");
        allStyles.forEach((style) => style.remove());

        const allMetaTags = document.querySelectorAll("meta");
        allMetaTags.forEach((meta) => meta.remove());

        // remove all images with width and height equal to 1
        const allImages = document.querySelectorAll("img");
        allImages.forEach((image) => {
          if (image.width <= 1 && image.height <= 1) {
            image.remove();
          }
        });
        console.log(allImages);

        console.log("[DEBUG] Cleaned DOM structure.");
        console.log(document);
      }

      function getBackgroundImageUrl(element) {
        if (!element) return null;

        const computedStyle = window.getComputedStyle(element);
        const background =
          computedStyle.background || computedStyle.backgroundImage;
        const urlMatch = background.match(/url\(["']?(.*?)["']?\)/);

        return urlMatch ? urlMatch[1] : null;
      }

      function checkAnchorTag(anchor, adWidth, adHeight) {
        const backgroundImage = getBackgroundImageUrl(anchor);

        if (backgroundImage) {
          console.log(
            "[DEBUG] Anchor background image found:",
            backgroundImage
          );

          const image = new Image();
          image.src = backgroundImage;

          return new Promise((resolve) => {
            image.onload = function () {
              const { width, height } = image;

              console.log(
                "[DEBUG] Anchor background dimensions:",
                width,
                height
              );

              if (
                width >= adWidth * 0.5 &&
                width <= adWidth * 1.5 &&
                height >= adHeight * 0.5 &&
                height <= adHeight * 1.5
              ) {
                console.log("[DEBUG] Anchor background dimensions match.");
                resolve(true);
              } else {
                resolve(false);
              }
            };
          });
        }

        return Promise.resolve(false);
      }

      function checkImageTag(image, adWidth, adHeight) {
        const { width, height } = image;

        console.log("[DEBUG] Image dimensions:", width, height);

        if (width === 1 && height === 1) {
          console.log("[DEBUG] Tracking pixel found, hiding image.");
          image.style.display = "none";
          return false;
        }

        if (
          width >= adWidth * 0.5 &&
          width <= adWidth * 1.5 &&
          height >= adHeight * 0.5 &&
          height <= adHeight * 1.5
        ) {
          console.log("[DEBUG] Image dimensions match.");
          return true;
        }

        return false;
      }

      //write a function to check button element and if clientWidth is more than 50px
      function checkButtonTag(button, adWidth, adHeight) {
        const { clientWidth, clientHeight } = button;

        console.log("[DEBUG] Button dimensions:", clientWidth, clientHeight);

        if (clientWidth >= 50) {
          console.log("[DEBUG] Button dimensions match.");
          return true;
        }

        return false;
      }
      function startPolling(iframe, adWidth, adHeight, onSuccess, onFailure) {
        const POLLING_INTERVAL = 500;
        const TIMEOUT = 5000;
        const pollingStartTime = Date.now();
        let impressionFired = false;

        // Function to check elements and fire impression
        const checkElements = async () => {
          if (impressionFired) return true;

          const allAnchorTags = iframe.contentDocument.querySelectorAll("a");
          const allImages = iframe.contentDocument.querySelectorAll("img");

          // Check all anchor tags first
          for (const anchor of allAnchorTags) {
            const isAnchorValid = await checkAnchorTag(
              anchor,
              adWidth,
              adHeight
            );
            if (isAnchorValid) {
              impressionFired = true;
              onSuccess();
              return true;
            }
          }

          // Check all images
          for (const image of allImages) {
            if (checkImageTag(image, adWidth, adHeight)) {
              impressionFired = true;
              onSuccess();
              return true;
            }
          }

          // Check all buttons
          const allButtons = iframe.contentDocument.querySelectorAll("button");
          for (const button of allButtons) {
            if (checkButtonTag(button, adWidth, adHeight)) {
              impressionFired = true;
              onSuccess();
              return true;
            }
          }

          return false;
        };

        // Initial check immediately
        checkElements();

        // Start polling
        const poll = setInterval(async () => {
          const elapsedTime = Date.now() - pollingStartTime;

          // Check for timeout first
          if (elapsedTime >= TIMEOUT) {
            clearInterval(poll);
            if (!impressionFired) {
              onFailure();
            }
            return;
          }

          // Continue checking elements
          const found = await checkElements();
          if (found) {
            clearInterval(poll);
          }
        }, POLLING_INTERVAL);

        // Cleanup function in case we need to stop polling externally
        return {
          stop: () => {
            clearInterval(poll);
          },
        };
      }
      // Main function
      renderAd()
        .then(({ iframe, adWidth, adHeight }) => {
          iframe.addEventListener("load", () => {
            console.log("[DEBUG] Ad rendered successfully");
            iframe.contentDocument.body.style.margin = "0px";
            // getCleanDomStructure(iframe.contentDocument);
            startPolling(
              iframe,
              adWidth,
              adHeight,
              () => {
                console.log("[DEBUG] Impression detected!");
                window.vuplex.postMessage({
                  type: "BannerAdWebViewImpression",
                });
              },
              () => {
                console.error("[ERROR] No impression detected!");
                window.vuplex.postMessage({ type: "BannerAdFailedImpression" });
              }
            );
          });

          iframe.addEventListener("error", () => {
            console.error("[ERROR] Iframe failed to load.");
            window.vuplex.postMessage({ type: "BannerAdFailed" });
          });
        })
        .catch((error) => {
          console.error("[ERROR] Error rendering ad:", error);
        });
    </script>
  </body>
</html>
